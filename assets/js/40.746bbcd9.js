(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{319:function(t,n,e){"use strict";e.r(n);var s=e(14),i=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"_1-刮刮乐-橡皮擦-效果的核心api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-刮刮乐-橡皮擦-效果的核心api"}},[t._v("#")]),t._v(" 1.刮刮乐（橡皮擦）效果的核心api")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("ctx.globalCompositeOperation = type;\n")])])]),n("p",[t._v("设置要在绘制新形状时应用的合成操作的类型。\n我们这里需要用到的类型是 "),n("code",[t._v("destination-out")]),t._v(" "),n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chendx97/CPics/img/e5c12874897c4199aabb4fd83d4bec25~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp",alt:"1206102951-61b0b351184c4_fix732.webp"}}),n("br"),t._v("\n此属性的详细信息："),n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation",target:"_blank",rel:"noopener noreferrer"}},[t._v("MDN文档"),n("OutboundLink")],1)]),t._v(" "),n("h2",{attrs:{id:"_2-基础版刮刮乐功能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-基础版刮刮乐功能"}},[t._v("#")]),t._v(" 2.基础版刮刮乐功能")]),t._v(" "),n("p",[t._v("canvs 覆盖在图片上")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chendx97/CPics/img/0c8a90facb104af6b99b2ca35dfd941e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp",alt:"1658915698-61b0b4e96c7e7.webp"}})]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('<style>\n    body {\n      margin: 0;\n    }\n    img {\n      width: 400px;\n      height: 300px;\n      left: 200px;\n      position: absolute;\n      z-index: -1;\n    }\n    canvas {\n      margin-left: 200px;\n    }\n  </style>\n  \n  <img src="./test.jpg" alt="pic"/>\n  <canvas id="canvas" width="400" height="300"></canvas>\n')])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("<script>\n   let canvas = document.querySelector('#canvas');\n   let context = canvas.getContext('2d');\n   // 绘制涂层\n   context.beginPath();\n   context.fillStyle = 'grey';\n   context.fillRect(0, 0, 400, 300);\n   // 监听鼠标移动事件\n   canvas.addEventListener('mousemove', (e) => {\n    // 当鼠标左键按下&&移动鼠标时，清除鼠标附近涂层\n    if (e.which === 1 && e.button === 0) {\n      const x = e.clientX, y = e.clientY;\n      context.globalCompositeOperation = 'destination-out';\n      context.beginPath();\n      // 清除以鼠标位置为圆心，半径为10px的圆的范围\n      context.arc(x - 200, y, 10, 0, Math.PI * 2);\n      context.fill();\n    }\n   })\n  <\/script>\n")])])]),n("h2",{attrs:{id:"_3-进阶版刮刮乐功能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-进阶版刮刮乐功能"}},[t._v("#")]),t._v(" 3.进阶版刮刮乐功能")]),t._v(" "),n("p",[t._v("进阶功能：\n点击时，以当前位置为圆心刮开一部分区域；\n刮开x百分比（可以自定义）后后显示全部，并且使用动画逐渐变淡；\n调用第一次刮的回调方法和刮完的回调方法，可以传入或不传；\n涂层上面可以显示自定义文字；")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chendx97/CPics/img/338e11a92b3741d18d5378f3f5481b76~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp",alt:"14236041-61b0b553e0efc.webp"}})]),t._v(" "),n("p",[t._v("首先改为class形式，方便多次创建刮刮乐。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("class Scratch {\n      constructor(id, { maskColor = 'grey', cursorRadius = 10 } = {}) {\n        this.canvas = document.getElementById('canvas');\n        this.context = this.canvas.getContext('2d');\n        this.width = this.canvas.clientWidth;\n        this.height = this.canvas.clientHeight;\n        this.maskColor = maskColor; // 涂层颜色\n        this.cursorRadius = cursorRadius; // 光标半径\n        this.init();\n      }\n      init() {\n        // 添加涂层\n        this.addCoat();\n        let bindEarse = this.erase.bind(this);\n        this.canvas.addEventListener('mousedown', (e) => {\n          // 按下左键\n          if (e.which === 1 && e.button === 0) {\n            // 擦掉涂层\n            this.canvas.addEventListener('mousemove', bindEarse);\n          }\n        })\n        document.addEventListener('mouseup', () => {\n          this.canvas.removeEventListener('mousemove', bindEarse);\n        })\n      }\n      addCoat() {\n        this.context.beginPath();\n        this.context.fillStyle = this.maskColor;\n        this.context.fillRect(0, 0, this.width, this.height);\n      }\n      erase(e) {\n        const x = e.clientX, y = e.clientY;\n        this.context.globalCompositeOperation = 'destination-out';\n        this.context.beginPath();\n        this.context.arc(x - this.width / 2, y, this.cursorRadius, 0, Math.PI * 2);\n        this.context.fill();\n      }\n    }\n    new Scratch('canvas');\n")])])]),n("p",[t._v("然后，记录鼠标位置，mouseup时判断是点击还是点击&移动鼠标，如果是点击则以当前位置为圆心刮开一部分区域；")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("this.canvas.addEventListener('mousedown', (e) => {\n      this.posX = e.clientX;\n      this.posY = e.clientY;\n      ...\n})\n document.addEventListener('mouseup', (e) => {\n    if (this.posX === e.clientX && this.posY === e.clientY) {\n      this.erase(e);\n    }\n     ...\n})\n")])])]),n("p",[t._v("然后，判断刮开面积是否超过一半，如果是清空涂层；")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("ImageData ctx.getImageData(sx, sy, sw, sh);\n")])])]),n("p",[t._v("sx：将要被提取的图像数据矩形区域的左上角 x 坐标。\nsy：将要被提取的图像数据矩形区域的左上角 y 坐标。\nsw：将要被提取的图像数据矩形区域的宽度。\nsh：将要被提取的图像数据矩形区域的高度。")]),t._v(" "),n("p",[t._v("ImageData 对象，包含canvas给定的矩形图像数据。可以用来判断是否被刮开。\n每4个元素表示一个像素点的rgba值，所以可以判断第4个的值是否小于256的一半即128，如果小于128即可视为透明（被刮开）。")]),t._v(" "),n("p",[t._v("清空指定区域内容：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("void ctx.clearRect(x, y, width, height);\n")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("document.addEventListener('mouseup', (e) => {\n   this.getScratchedPercentage();\n    if (this.currPerct >= this.maxEraseArea) {\n        this.context.clearRect(0, 0, this.width, this.height);\n    }\n})\n\ngetScratchedPercentage() {\n    const pixels = this.context.getImageData(0, 0, this.width, this.height).data;\n    let transparentPixels = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n         if (pixels[i + 3] < 128) {\n            transparentPixels++;\n          }\n    }\n    this.currPerct = (transparentPixels / pixels.length * 4 * 100).toFixed(2);\n}\n")])])]),n("p",[t._v("然后，设置第一次刮的回调方法和刮完的回调方法；")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("constructor(id, { maskColor = 'grey', cursorRadius = 10, maxEraseArea = 50,\n    firstEraseCbk = () => { }, lastEraseCbk = () => { } } = {}) {\n    ...\n    this.firstEraseCbk = firstEraseCbk; // 第一次刮的回调函数\n    this.lastEraseCbk = lastEraseCbk; // 刮开的回调函数\n}\n\nthis.canvas.addEventListener('mousedown', (e) => { \n    if (this.currPerct === 0) {\n        this.firstEraseCbk();\n    }\n})\ndocument.addEventListener('mouseup', (e) => {\n    if (this.currPerct >= this.maxEraseArea) {\n        this.context.clearRect(0, 0, this.width, this.height);\n        this.lastEraseCbk();\n    }\n})\n")])])]),n("p",[t._v("然后，刮开全部时慢慢清空涂层，设置背景色渐变效果；\n"),n("code",[t._v("requestAnimationFrame")]),t._v(" 做出来的动画更流畅\n回调函数用闭包形式可以给回调函数传参")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("document.addEventListener('mouseup', (e) => {\n    if (this.currPerct >= this.maxEraseArea) {\n        this.done = true;\n        requestAnimationFrame(this.fadeOut(255));\n         this.lastEraseCbk();\n    }\n})\n\nfadeOut(alpha) {\n    return () => {\n          this.context.save();\n          this.context.globalCompositeOperation = 'source-in';\n          this.context.fillStyle = this.context.fillStyle + (alpha -= 1).toString(16);\n          this.context.fillRect(0, 0, this.width, this.height);\n          this.context.restore();\n          // 到210已经看不到涂层了\n          if (alpha > 210) {\n            requestAnimationFrame(this.fadeOut(alpha));\n          }\n     }\n}\n")])])]),n("p",[t._v("然后，初始化涂层的时候，再涂层上显示自定义文字；")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("addCoat() {\n        ...\n        if (this.text) {\n          this.context.font = 'bold 48px serif';\n          this.context.fillStyle = '#fff';\n          this.context.textAlign = 'center';\n          this.context.textBaseline = 'middle';\n          this.context.fillText(this.text, this.width / 2, this.height / 2);\n        }\n}\n")])])]),n("h2",{attrs:{id:"完整代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#完整代码"}},[t._v("#")]),t._v(" 完整代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("<!DOCTYPE html>\n<html lang=\"en\">\n\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    body {\n      margin: 0;\n    }\n\n\n    img {\n      width: 400px;\n      height: 300px;\n      left: 200px;\n      position: absolute;\n      z-index: -1;\n    }\n\n\n    canvas {\n      margin-left: 200px;\n    }\n  </style>\n</head>\n\n\n<body>\n  <img src=\"./test.jpg\" alt=\"pic\" />\n  <canvas id=\"canvas\" width=\"400\" height=\"300\"></canvas>\n  <script>\n    class Scratch {\n      constructor(id, { maskColor = 'grey', cursorRadius = 10, maxEraseArea = 50, text = '',\n        firstEraseCbk = () => { }, lastEraseCbk = () => { } } = {}) {\n        this.canvasId = id;\n        this.canvas = document.getElementById(id);\n        this.context = this.canvas.getContext('2d');\n        this.width = this.canvas.clientWidth;\n        this.height = this.canvas.clientHeight;\n        this.maskColor = maskColor; // 涂层颜色\n        this.cursorRadius = cursorRadius; // 光标半径\n        this.maxEraseArea = maxEraseArea; // 刮开多少后自动清空涂层\n        this.text = text;\n        this.firstEraseCbk = firstEraseCbk; // 第一次刮的回调函数\n        this.lastEraseCbk = lastEraseCbk; // 刮开的回调函数\n        this.currPerct = 0; // 当前刮开多少百分比\n        this.done = false; // 是否刮完\n        this.init();\n      }\n      init() {\n        // 添加涂层\n        this.addCoat();\n        let bindEarse = this.erase.bind(this);\n        this.canvas.addEventListener('mousedown', e => {\n          if (this.done) {\n            return;\n          }\n          this.posX = e.clientX;\n          this.posY = e.clientY;\n          // 按下左键\n          if (e.which === 1 && e.button === 0) {\n            // 擦掉涂层\n            this.canvas.addEventListener('mousemove', bindEarse);\n          }\n          if (this.currPerct === 0) {\n            this.firstEraseCbk();\n          }\n        })\n        document.addEventListener('mouseup', e => {\n          if (this.done) {\n            return;\n          }\n          if (e.target.id !== this.canvasId) {\n            return;\n          }\n          if (this.posX === e.clientX && this.posY === e.clientY) {\n            this.erase(e);\n          }\n          this.canvas.removeEventListener('mousemove', bindEarse);\n          this.getScratchedPercentage();\n          if (this.currPerct >= this.maxEraseArea) {\n            this.done = true;\n            requestAnimationFrame(this.fadeOut(255));\n            this.lastEraseCbk();\n          }\n        })\n      }\n      // 添加涂层\n      addCoat() {\n        this.context.beginPath();\n        this.context.fillStyle = this.maskColor;\n        this.context.fillRect(0, 0, this.width, this.height);\n        // 绘制涂层上的文字\n        if (this.text) {\n          this.context.font = 'bold 48px serif';\n          this.context.fillStyle = '#fff';\n          this.context.textAlign = 'center';\n          this.context.textBaseline = 'middle';\n          this.context.fillText(this.text, this.width / 2, this.height / 2);\n        }\n      }\n      // 擦除某位置涂层\n      erase(e) {\n        const x = e.clientX, y = e.clientY;\n        this.context.globalCompositeOperation = 'destination-out';\n        this.context.beginPath();\n        this.context.arc(x - this.width / 2, y, this.cursorRadius, 0, Math.PI * 2);\n        this.context.fill();\n      }\n      // 计算被擦除的部分占全部的百分比\n      getScratchedPercentage() {\n        const pixels = this.context.getImageData(0, 0, this.width, this.height).data;\n        let transparentPixels = 0;\n        for (let i = 0; i < pixels.length; i += 4) {\n          if (pixels[i + 3] < 128) {\n            transparentPixels++;\n          }\n        }\n        this.currPerct = (transparentPixels / pixels.length * 4 * 100).toFixed(2);\n      }\n      // 清空涂层时淡出效果\n      fadeOut(alpha) {\n        return () => {\n          this.context.save();\n          this.context.globalCompositeOperation = 'source-in';\n          this.context.fillStyle = this.context.fillStyle + (alpha -= 1).toString(16);\n          this.context.fillRect(0, 0, this.width, this.height);\n          this.context.restore();\n          // 到210已经看不到涂层了\n          if (alpha > 210) {\n            requestAnimationFrame(this.fadeOut(alpha));\n          }\n        }\n      }\n    }\n    new Scratch('canvas', { text: '刮一刮', maxEraseArea: 10 });\n  <\/script>\n</body>\n\n\n</html>\n")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);